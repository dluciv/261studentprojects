Не идеально.
 1- Код плохо форматирован
2- Как соотноятся Graph.getNextState и Minimization.getNextSt ? Если первый работает не правильно, то почему не исправить его? А что такое getStates ?
3- Как соотносятся Graph.nextStateIndex и Minimization.MaxStId ?
4- странный тип HashMap<Integer, ArrayList<Integer>> для EqualPares и NonEqualPares, Вам так не кажется?
Возможно стоит добавить комментарий, почему ввыбьран такой тип, а не, например, множество множеств состояний.
5- HashMap<Integer, ArrayList<Integer>> для NewFront и NextFront тоже выглядит странно. Почему не просто список?
6- Почему revgraph имеет тип HashMap<Integer, ArrayList<Integer>>, а не Graph? Верно ли, что Graph не соответсвует своему названию? Тогда исправьте заодно и это.
7- public Graph DFA; - хорошая практика называть поля с маленькой буквы, чтобы отличать их от классов.
8- Minimization(Graph TMDFA) - аргументы функции тожею А что обозначают буквы "TM"?
9- getEqualPares - "пара" пишется как pair
10- int flag2 = 0; - пока есть такое, код не считается приемлемым.
11- реализация addOneInNewFront() как-то подозрительно много места занимает. Она точно делает то, про что говорится в названии?
12- действительно ли все методы класса Minimization должны быть public?
13- Является ли метод minimizeDFA переиспользуемым? Т.е. получится ли правлиный результат, если его вызвать второй раз?
14- что такое public HashMap<Integer, Integer> classes ?
15- что такое public int h ?
16- гляжу на addOneWithoutRep и удивлясь: исходный граф изменяется?
17- Мда, я мог это и из minimizeDFA увидеть. Вы же таким поведением вводите в заблужение всех, кто не прочитал внимательно Ваш код. А прочитать Ваш код довольно трудно: Вы об этом позаботились. ;)
Как вы думаете, чему должно быть равно значение переменной i после выполнения следующего примера:
 int i = 1;
 int j = i - 1;
 ?
А если заменить int на Graph, а -1 на Minimization.minimizeDFA ?


В общем, до красивого кода ещё далеко.


Кстати, я не посмотрел, надеюсь Вы приложили тесты на минимизацию?


С уважением,
Виктор



1-Постарался исправить.
2-Первый действительно работает неправильно. Он вместо Null возвращает пустой nStatesListCh. Это сделано спциально и для каких целей я не знаю. Изменять чужой код я не имею права.
   т.ч. я просто вместо проверки != null поставил проверку ".size != 0"  и начал пользоваться первым методом.
3-Никак. Первый не изменяется больше чем один раз и после изменения всегда равен 3 тч никакой полезной информации не несет. Он как мне кажется вообще не нужен.  MaxStId берет максимальный номер состояния из графа и прибавляет двойку.

4-Удобнее работать и разбивать на классы эквивалентности. Есть головной элемент класса - в такой структуре это ключ хэша. 
5-Аналогично.
6-Нет не верно. Все исправил. теперь revgraph типа Graph.
7-исправил.
8-исправил.
9-исправил.
10-исправил.
11-Точно. Просто проверяем чтоб небыло повторяющихся пар.
12-Совсем не все. Только один:)
13-Теперь да. Можно вызывать как последовательно так и рекурсивно.
14-Структура для транзитивного замыкания. Classes - классы по отношению эквивалентности.
15-h-новое состояние которое требуется для корректной работы алгоритма(Было на лекциях. h - общепринятое название)
16-Теперь это нам не мешает.
17--..--..--..--

С уважением,
Сергей